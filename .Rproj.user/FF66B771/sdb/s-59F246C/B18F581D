{
    "collab_server" : "",
    "contents" : "#include <math.h>    // math routines\n#include \"ANN.h\"     // ANN library header\n#include <Rcpp.h>       // R header\n\n//------------------------------------------------------------------------------------------------\n//\t\t\t\t Near Neighbours Program\n//------------------------------------------------------------------------------------------------\nextern \"C\"\n{\n\tvoid get_NN(double *data, int *mask, int *sumMask, int *k, int *dim, int *m_pts, int *nn_index,\n\t\tdouble *distances)\n\t{\n\tconst int d = *dim;\t\t// Actual Dimension\n\tconst int M = *m_pts;\t\t// Number of Data points\n\tconst double error_bound = 00.00;\t// enough said!\n\tconst int numNN = *k;\t\t// Max. num of NN\n\tANNpointArray\tdata_pts;\t// Data points\n\tANNpointArray\toutput_pts;\t// Query point\n\tANNidxArray\tnn_idx;\t\t// Near neighbor indices\n\tANNdistArray\tdists;\t\t// Near neighbor distances\n\tANNkd_tree\t*the_tree;\t// Search structure\n\n\toutput_pts \t= annAllocPts(M, 1);\t\t// Allocate query point\n\tdata_pts \t= annAllocPts(M, *sumMask);\t// Allocate data points\n\t// NB +1 is to allow for return of the point itself which will be\n\t// the nearest neighbour with v1.1.1 of the ANN library\n\tnn_idx \t\t= new ANNidx[numNN+1];\t\t// Allocate near neigh indices\n\tdists \t\t= new ANNdist[numNN+1];\t\t// Allocate near neighbor dists\n\n\tint incOutputData = (d-1)*M;\n\tint *d_ptr = new int[d-1];\n\tint ptr = 0;\n\n\t// Next 2 for loops are concerned with getting the linear R array into the ANN format\n\tfor(int i = 0; i < (d-1); i++)\n\t{\n\t\td_ptr[i] = 0;\n\t\td_ptr[i] = i*M;\n\t} // end for\n\n\tfor(int i = 0; i < M; i++) // now construct the points\n\t{\n\t\tANNpoint p = new ANNcoord[*sumMask];\n\t\tint myJ = 0;\n\t\tfor(int j = 0; j < d-1; j++)\n\t\t{\n\t\t\tint temp = d_ptr[j];\n\n\t\t\tif(mask[j] == 1)\n\t\t\t{\n\t\t\t\tp[myJ] = 00.00;\n\t\t\t\tp[myJ] = data[temp];\n\t\t\t\tmyJ++;\n\t\t\t}\n\n\t\t\td_ptr[j] = 0;\n\t\t\td_ptr[j] = temp + 1;\n\t\t} // end inner for loop\n\n\t\tdata_pts[i] = p;\n\t\tANNpoint o;\n\t\to = new ANNcoord[1];\n\t\to[0] = data[incOutputData];\n\t\toutput_pts[i] = o;\n\t\tincOutputData++;\n\t} // end for\n\n\tthe_tree = new ANNkd_tree(\t// Build search structure\n\t\t\tdata_pts,\t\t// The data points\n\t\t\tM,\t\t\t// Number of points\n\t\t\t*sumMask);\t\t// Dimension of space\n\n\tfor(int i = 0; i < M; i++)\t// read query points\n\t{\n\t\tthe_tree->annkSearch(\t// search\n\t\t\tdata_pts[i],\t// query point\n\t\t\tnumNN+1,\t\t// number of near neighbors\n\t\t\tnn_idx,\t\t// nearest neighbors (returned)\n\t\t\tdists,\t\t// distance (returned)\n\t\t\terror_bound);\t// error bound\n\n\t\tfor (int j = 1; j <= numNN; j++)\n\t\t{\n\t\t\tdistances[ptr] = sqrt(dists[j]);\t// unsquare distance\n\t\t\tnn_index[ptr]  = nn_idx[j] + 1;\t\t\t// put indexes in returned array\n\t\t\tptr++;\n\t\t} // end inner for\n\t} // end for\n\n\t// Do a little bit of memory management......\n\tdelete data_pts;\n\tdelete output_pts;\n\tdelete nn_idx;\n\tdelete dists;\n\tdelete the_tree;\n\tdelete [] d_ptr;\n\t}\n\t\n\tvoid get_NN_2Set(double *data, double *query, int *D, int *ND, int *NQ, int *K, double *EPS,\n\t\tint *SEARCHTYPE, int *USEBDTREE, double *SQRAD, int *nn_index, double *distances)\n\t{\n\tconst int d = *D;\t\t// Number of Dimensions for points\n\tconst int nd = *ND;\t\t// Number of Data points\n\tconst int nq= *NQ;\t\t// Number of Query points\n\tconst int k = *K;\t\t// Maximum number of Nearest Neighbours\n\n\tconst int searchtype = *SEARCHTYPE;\n\tconst bool usebdtree = *USEBDTREE?true:false;\n\n\tconst double error_bound = *EPS;\t// enough said!\n\tconst double sqRad = *SQRAD;\t\t// Squared Radius for rad search\n\t\n\tANNkd_tree\t*the_tree;\t// Search structure\n\n\tANNpointArray data_pts \t= annAllocPts(nd,d);\t\t// Allocate data points\n\tANNidxArray nn_idx \t\t= new ANNidx[k];\t\t// Allocate near neigh indices\n\tANNdistArray dists \t\t= new ANNdist[k];\t\t// Allocate near neighbor dists\n\n\tint *d_ptr = new int[d];\n\tint ptr = 0;\n\t\n\t// set up column offsets for query point matrix (to convert Row/Col major)\n\tfor(int i = 0; i < d; i++)\n\t{\n\t\td_ptr[i] = i*nd;\n\t}\n\n\tfor(int i = 0; i < nd; i++) // now construct the points\n\t{\n\t\tfor(int j = 0; j < d; j++)\n\t\t{\n\t\t\tdata_pts[i][j]=data[ d_ptr[j]++ ];\n\t\t}\n\t}\n\t\n\tif(usebdtree){\n\t\tthe_tree = new ANNbd_tree(\t// Build search structure\n\t\t\t\tdata_pts,\t\t\t// The data points\n\t\t\t\tnd,\t\t\t\t\t// Number of data points\n\t\t\t\td);\t\t\t\t\t// Dimension of space\t\t\t\t\n\t} else {\n\t\tthe_tree = new ANNkd_tree( data_pts, nd, d);\n\t}\n\n\t// set up offsets for query point matrix (to convert Row / Col major)\n\tfor(int i = 0; i < d; i++)\n\t{\n\t\td_ptr[i] = i*nq;\n\t}\n\t\n\tANNpoint pq = annAllocPt(d);\n\tfor(int i = 0; i < nq; i++)\t// Run all query points against tree\n\t{\n\t\t// read coords of current query point\n\t\tfor(int j = 0; j < d; j++)\n\t\t{\n\t\t\tpq[j]=query[ d_ptr[j]++ ];\n\t\t}\n\t\t\n\t\tswitch(searchtype){\n\t\t\tcase 1:\n\t\t\tthe_tree->annkSearch(\t// search\n\t\t\t\tpq,\t// query point\n\t\t\t\tk,\t\t// number of near neighbors\n\t\t\t\tnn_idx,\t\t// nearest neighbors (returned)\n\t\t\t\tdists,\t\t// distance (returned)\n\t\t\t\terror_bound);\t// error bound\t\t\t\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 2:  // Priority search\n\t\t\tthe_tree->annkPriSearch(pq, k, nn_idx, dists, error_bound);\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 3: // Fixed radius search \n\t\t\tthe_tree->annkFRSearch(\tpq,\tsqRad, k, nn_idx, dists,error_bound);\t\t\t\n\t\t\tbreak;\n\t\t}\t\t\n\n\t\tfor (int j = 0; j < k; j++)\n\t\t{\n\t\t\tdistances[ptr] = sqrt(dists[j]);\t// unsquare distance\n\t\t\tnn_index[ptr++]  = nn_idx[j] + 1;\t// put indices in returned array\n\t\t}\n\t}\n\n\t// Do a little bit of memory management......\n\tannDeallocPt(pq);\n\tannDeallocPts(data_pts);\n\tdelete [] nn_idx;\n\tdelete [] dists;\n\tdelete [] d_ptr;\n\tdelete the_tree;\n\t}\n}\n\n\n/* Rcpp wrapper for the get_NN_2Set_wrapper function */\n// [[Rcpp::export]]\nRcpp::List get_NN_2Set_wrapper(const Rcpp::NumericMatrix& data, const Rcpp::NumericMatrix& query,\n                               int dimension, int ND, int NQ, int K, \n                         double EPS, int SEARCHTYPE, int USEBDTREE, double SQRAD,\n                         Rcpp::IntegerVector& nn_index, Rcpp::NumericVector& distances) {\n\n  std::vector<double> data_vec(ND * dimension);\n  std::vector<double> query_vec(NQ * dimension);\n  int data_vec_it = 0;\n  int query_vec_it = 0;\n  for (int j=0; j < dimension; j++) {\n    for (int i=0; i < ND; i++, data_vec_it++) {\n      data_vec[data_vec_it] = data(i, j);\n    }\n    for (int i=0; i < NQ; i++, query_vec_it++) {\n      query_vec[query_vec_it] = query(i, j);\n    }\n  }\n  get_NN_2Set(&data_vec[0], &query_vec[0], &dimension, &ND, &NQ, &K, &EPS,\n              &SEARCHTYPE, &USEBDTREE, &SQRAD, &nn_index(0), &distances(0));\n  return Rcpp::List::create(Rcpp::Named(\"nn_index\") = nn_index,\n                            Rcpp::Named(\"distances\") = distances); \n}\n",
    "created" : 1501178228831.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2027553655",
    "id" : "B18F581D",
    "lastKnownWriteTime" : 1501179269,
    "last_content_update" : 1501179269724,
    "path" : "~/Code/R/nonlineartseries/src/NN.cpp",
    "project_path" : "src/NN.cpp",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}