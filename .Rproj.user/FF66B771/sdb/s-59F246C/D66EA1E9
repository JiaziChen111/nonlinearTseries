{
    "collab_server" : "",
    "contents" : "########################### Determining embedding dimension ####################\n#' Estimate the embedding dimension\n#' @description\n#' This function determines the minimum embedding dimension from a scalar time \n#' series using the algorithm proposed by L. Cao (see references).\n#' @details\n#' The Cao's algorithm uses 2 functions in order to estimate the embedding dimension\n#' from a time series: the E1(d) and the E2(d) functions, where d denotes the dimension.\n#' \n#' E1(d) stops changing when d is greater than or equal to the embedding dimension, staying close to 1.\n#' On the other hand, E2(d) is used to distinguish deterministic signals from stochastic signals. For \n#' deterministic signals, there exist some d such that E2(d)!=1. For stochastic signals,\n#' E2(d) is approximately 1 for all the values. \n#' \n#' This function uses the Arya and Mount's C++ ANN library for nearest neighbour search \n#' (For more information on the ANN library please visit \\url{http://www.cs.umd.edu/~mount/ANN/}).\n#' The R wrapper is a modified version of the RANN package code by Samuel E. Kemp and Gregory Jefferis.\n#' @note\n#' In the current version of the package, the automatic detection of stochastic \n#' signals has not been implemented yet.\n#' @param time.series The original time series.\n#' @param number.points Number of points from the time series that will be used to estimate\n#' the embedding dimension. By default, all the points in the time series are used.\n#' @param time.lag Time lag used to build the Takens' vectors needed to estimate the\n#' embedding dimension (see \\link{buildTakens}). Default: 1.\n#' @param max.embedding.dim Maximum possible embedding dimension for the time series. Default: 15.\n#' @param threshold Numerical value between 0 and 1. The embedding dimension is estimated\n#' using the E1(d) function. E1(d) stops changing when d is greater than or equal to\n#' embedding dimension, staying close to 1. This value establishes a threshold for \n#' considering that E1(d) is close to 1. Default: 0.95\n#' @param max.relative.change Maximum relative change in E1(d) with respect to \n#' E1(d-1) in order to consider that the E1 function has been stabilized and it will\n#' stop changing. Default: 0.01.\n#' @param do.plot Logical value. If TRUE (default value), a plot of E1(d) and E2(d) is shown.\n#' @param main Title for the plot.\n#' @param xlab Title for the x axis.\n#' @param ylab Title for the y axis.\n#' @param xlim numeric vectors of length 2, giving the x coordinates range.\n#' @param ylim numeric vectors of length 2, giving the y coordinates range.\n#' @references \n#' Cao, L. Practical method for determining the minimum embedding dimension of a scalar time series. Physica D: Nonlinear Phenomena,\n#' 110,1, pp. 43-50 (1997).\n#' \n#' Arya S. and Mount D. M. (1993), Approximate nearest neighbor searching, Proc. 4th Ann. ACM-SIAM Symposium on Discrete Algorithms (SODA'93), 271-280.\n#' \n#' Arya S., Mount D. M., Netanyahu N. S., Silverman R. and Wu A. Y (1998), An optimal algorithm for approximate nearest neighbor searching, Journal of the ACM, 45, 891-923.\n#' @author Constantino A. Garcia\n#' @examples \n#' \\dontrun{\n#' h = henon(do.plot=FALSE) \n#' dimension = estimateEmbeddingDim(h$x, time.lag=1, max.embedding.dim=6,\n#'              threshold=0.9, do.plot=TRUE)\n#'              }\n#' @export estimateEmbeddingDim\nestimateEmbeddingDim = function(time.series,  number.points = length(time.series), \n                                time.lag = 1,  max.embedding.dim = 15,  threshold = 0.95, \n                                max.relative.change = 0.10,\n                                do.plot = TRUE,\n                                main = \"Computing the embedding dimension\",\n                                xlab=\"dimension (d)\", ylab=\"E1(d) & E2(d)\",\n                                ylim = NULL, xlim = NULL){\n  kSDFraction = 1e-6\n  \n  if (max.embedding.dim < 3) stop(\"max.embedding.dim should be greater that 2...\\n\")\n  # normalize time series\n  time.series = (time.series - mean(time.series,na.rm = T) ) / sd(time.series, na.rm = T)\n  time.series.len = length(time.series)\n  # add small quantity of noise to avoid finding identical phase space\n  # points (something impossible in a pure chaotic signal). This \"trick\"\n  # avoids failures when supplying periodic signals (i.e. a sine).\n  # We use the IQR as an estimation of the time.series dispersion to\n  # avoid the effect of outliers\n  time.series = time.series +\n    rnorm(time.series.len, \n          sd = IQR(time.series,na.rm = T) * kSDFraction) \n  data = time.series[(time.series.len/2-number.points/2+1):(time.series.len/2+number.points/2)]\n  #if no d verifies E1(d) >= threshold,  then we shall return 0\n  embedding.dim = 0 \n  # First iteration: get E1(1) and E2(1)\n  E.parameters = getCaoParameters(data,  1,  time.lag)\n  E.parameters.next.dim = getCaoParameters(data,  2,  time.lag)\n  E.vector = c(E.parameters$E,  E.parameters.next.dim$E)\n  E.star.vector = c(E.parameters$E.star,  E.parameters.next.dim$E.star)\n  E1.vector = c(E.vector[[2]]/E.vector[[1]])\n  E2.vector = c(E.star.vector[[2]]/E.star.vector[[1]])\n  # compute from d = 3 to d = max.embedding.dim\n  for (dimension in 3:max.embedding.dim){\n    #compute E parameters, E1 and E2\n    E.parameters = getCaoParameters(data, dimension, time.lag)\n    E.vector[[dimension]] = E.parameters$E\n    E.star.vector[[dimension]] = E.parameters$E.star\n    E1.vector[[dimension-1]] = E.vector[[dimension]]/E.vector[[dimension-1]]\n    E2.vector[[dimension-1]] = E.star.vector[[dimension]]/E.star.vector[[dimension-1]]\n    # Error for dimension - 2\n    relative.error = abs(E1.vector[[dimension-1]]-E1.vector[[dimension-2]])/(E1.vector[[dimension-2]])\n    #compute if E1(d)>=threshold...If it is the first time it happens(embedding.dim==0), store\n    # the dimension\n    if ((embedding.dim==0) && (!is.na(E1.vector[[dimension - 2]])) &&\n          (E1.vector[[dimension-2]]>=threshold) &&\n          (relative.error < max.relative.change )){\n      embedding.dim = dimension - 2\n    }\n  }\n  #plot graphics\n  if (do.plot){\n    if (is.null(ylim)){\n      ylim = c(0,max(E1.vector,E2.vector))\n    }\n    if (is.null(xlim)){\n      xlim = c(1,length(E1.vector))\n    }\n    plot(1:length(E1.vector), E1.vector, 'b',lty=1,pch=1,\n         main=main,ylab=ylab,xlab=xlab, cex = 1, ylim = ylim, xlim=xlim)\n    lines(1:length(E2.vector), E2.vector, 'b',lty=2,pch=2, col = 2, cex = 1)\n    abline(h = c(1, threshold), col = 3, lwd=2,lty = c(3, 3))\n    legend(\"bottomright\", col = 1:3, lty = 1:3, lwd = c(2.5, 2.5, 2.5),\n           pch=c(1,2,NA),bty=\"n\",\n           legend = c(\"E1(d)\", \"E2(d)\", \"limits for E1(d)\"))\n    \n  }\n  return (embedding.dim)\n  \n}\n\n\n# private function\n# auxiliar function to compute E,  E1 and E2 based on the \n# L.Cao article: Practical method for determining the minimum embedding dimension of a scalar time series.\ngetCaoParameters = function(data, m, time.lag){\n  # theshold for considering that two vectors are at distance 0\n  kZero = 1e-15\n  #construct takens vectors of dimensions m and m+1\n  takens = buildTakens(data,  m,  time.lag)\n  takens.next.dimension = buildTakens(data,  m+1,  time.lag)\n  #get closest neigh\n  max.iter = nrow(takens.next.dimension)\n  if (m==1){\n    nearest.neigh = nn.search(data = matrix(data[1:max.iter],ncol=1), query = matrix(data[1:max.iter],ncol=1), k=2, eps=0)\n  }else{\n    nearest.neigh = nn.search(data = takens[1:max.iter,], query= takens[1:max.iter,], k=2, eps=0)\n  } \n  # the a(i, d) parameter from the Cao's article (Equation 1) will be call here\n  # min.dist.ratio. On the other hand,  the expression inside the summatory in \n  # equation 4 will be called stochastic.parameter\n  min.dist.ratio = c()\n  stochastic.parameter = c()\n  #computing...\n  for (takens.position in 1:max.iter){\n    # get closest neighbour (avoid picking the same vector with the 2 index)\n    closest.neigh = nearest.neigh$nn.idx[takens.position,2] \n    if (nearest.neigh$nn.dists[takens.position, 2] < kZero){\n      # We found equal points in phase space... assing NA     \n      min.dist.ratio[[takens.position]] = NA\n    }else{\n      numerator = as.numeric(dist(rbind(takens.next.dimension[takens.position, ], takens.next.dimension[closest.neigh, ]),  method = \"maximum\"))\n      min.dist.ratio[[takens.position]] = numerator/nearest.neigh$nn.dists[takens.position, 2]\n    }\n    \n    stochastic.parameter[[takens.position]] = abs(data[[takens.position+m*time.lag]]-data[[closest.neigh+m*time.lag]])\n  }\n\n  return (list(E = mean(min.dist.ratio,na.rm=TRUE), E.star = mean(stochastic.parameter,na.rm=TRUE)))\n}\n",
    "created" : 1501177993059.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2743855454",
    "id" : "D66EA1E9",
    "lastKnownWriteTime" : 1496226809,
    "last_content_update" : 1496226809,
    "path" : "~/Code/R/nonlineartseries/R/getMinimumEmbeddingDimension.R",
    "project_path" : "R/getMinimumEmbeddingDimension.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}